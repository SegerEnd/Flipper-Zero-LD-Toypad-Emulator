#include "EmulateToyPad_scene.h"

#include "../ldtoypad.h"

#include <furi.h>
#include <furi_hal.h>

/* generated by fbt from .png files in images folder */
#include <ldtoypad_icons.h>

#include <gui/elements.h>
// #include <gui/icon_i.h> // Not yet needed apparently

#define numBoxes 7 // the number of boxes (7 boxes always)

LDToyPadApp* app;

FuriHalUsbInterface* usb_mode_prev = NULL;

// Selection box icon
uint8_t I_selectionBox[] = {0xf8, 0xff, 0x00, 0x06, 0x00, 0x01, 0x03, 0x00, 0x02, 0x03, 0x00,
                            0x02, 0x03, 0x00, 0x02, 0x03, 0x00, 0x02, 0x03, 0x00, 0x02, 0x03,
                            0x00, 0x02, 0x03, 0x00, 0x02, 0x03, 0x00, 0x02, 0x03, 0x00, 0x02,
                            0x03, 0x00, 0x02, 0x03, 0x00, 0x02, 0x03, 0x00, 0x02, 0x03, 0x00,
                            0x02, 0x07, 0x00, 0x03, 0xfe, 0xff, 0x01, 0xfc, 0xff, 0x00};

//  Selection circle icon
uint8_t I_selectionCircle[] = {0x80, 0x7f, 0x00, 0xf0, 0xff, 0x03, 0xf8, 0xc0, 0x07, 0x3c, 0x00,
                               0x0f, 0x0c, 0x00, 0x0c, 0x06, 0x00, 0x18, 0x07, 0x00, 0x38, 0x07,
                               0x00, 0x38, 0x03, 0x00, 0x30, 0x03, 0x00, 0x30, 0x07, 0x00, 0x38,
                               0x06, 0x00, 0x18, 0x06, 0x00, 0x18, 0x3e, 0x00, 0x1f, 0xf8, 0xc0,
                               0x07, 0xf0, 0xff, 0x03, 0x80, 0x7f, 0x00};

// Define box information (coordinates and dimensions) for each box (7 boxes total)
int boxInfo[numBoxes][2] = {
    {18, 26}, // Selection 0 (box)
    {50, 20}, // Selection 1 (circle)
    {85, 27}, // Selection 2 (box)
    {16, 40}, // Selection 3 (box)
    {35, 41}, // Selection 4 (box)
    {70, 41}, // Selection 5 (box)
    {86, 40} // Selection 6 (box)
};

struct LDToyPadSceneEmulate {
    View* view;
    // LDToyPadSceneEmulateCallback callback;
    // void* context;

    // timer
    FuriTimer* timer; // Timer for redrawing the screen
};

// The selected pad on the toypad
uint8_t selectedBox = 0; // Variable to keep track of which toypad box is selected

bool ldtoypad_scene_emulate_input_callback(InputEvent* event, void* context) {
    LDToyPadSceneEmulate* instance = context;
    furi_assert(instance);

    bool consumed = false;

    with_view_model(
        instance->view,
        LDToyPadSceneEmulateModel * model,
        {
            // when the OK button is pressed, we want to switch to the minifigure selection screen for the selected box
            if(event->key == InputKeyOk) {
                if(event->type == InputTypePress) {
                    model->ok_pressed = true;

                    // set current view to minifigure selection screen
                    view_dispatcher_switch_to_view(app->view_dispatcher, ViewMinifigureSelection);

                    // submenu_reset(selectionMenu);

                    // for(int i = 0; minifigures[i].name != NULL; i++) {
                    //     submenu_add_item(
                    //         selectionMenu,
                    //         minifigures[i].name,
                    //         minifigures[i].id,
                    //         selectionMenu_callback,
                    //         minifigures);
                    // }
                    // view_dispatcher_switch_to_view(
                    //     ldtoypad_view_dispatcher, LDToyPadView_SelectionMenu);

                    consumed = true;
                    return consumed;

                } else if(event->type == InputTypeRelease) {
                    model->ok_pressed = false;
                }
            }
            // make user loop through boxes with InputKeyLeft, InputKeyRight, InputKeyUp, InputKeyDown
            if(event->key == InputKeyLeft) {
                if(event->type == InputTypePress) {
                    model->left_pressed = true;
                    if(selectedBox == 0) {
                        selectedBox = numBoxes;
                    }
                    selectedBox--;
                } else if(event->type == InputTypeRelease) {
                    model->left_pressed = false;
                }
            }
            if(event->key == InputKeyRight) {
                if(event->type == InputTypePress) {
                    model->right_pressed = true;
                    selectedBox++;
                    if(selectedBox >= numBoxes) {
                        selectedBox = 0;
                    }
                } else if(event->type == InputTypeRelease) {
                    model->right_pressed = false;
                }
            }
            if(event->key == InputKeyUp) {
                if(event->type == InputTypePress) {
                    model->up_pressed = true;
                    if(selectedBox == 0) {
                        selectedBox = 3;
                    } else if(selectedBox >= 4) {
                        selectedBox -= 4;
                    } else {
                        selectedBox = (numBoxes - 3) + selectedBox;
                    }
                    if(selectedBox >= numBoxes) {
                        selectedBox = 0;
                    }
                } else if(event->type == InputTypeRelease) {
                    model->up_pressed = false;
                }
            }

            if(event->key == InputKeyDown) {
                if(event->type == InputTypePress) {
                    model->down_pressed = true;
                    if(selectedBox == 2) {
                        selectedBox = 6;
                    } else if(selectedBox == 3) {
                        selectedBox = 0;
                    } else if(selectedBox == 5) {
                        selectedBox = 2;
                    } else if(selectedBox < (numBoxes - 3)) {
                        selectedBox += 3;
                    } else {
                        selectedBox = selectedBox - (numBoxes - 3);
                    }
                } else if(event->type == InputTypeRelease) {
                    model->down_pressed = false;
                }
            }
        },
        true);

    return consumed;
}

unsigned char generate_checksum_for_command(const unsigned char* command, size_t len) {
    // Assert that the length of the command is less than or equal to 31
    assert(len <= 31);

    unsigned char result = 0;

    // Add bytes, wrapping naturally with unsigned char overflow
    for(size_t i = 0; i < len; ++i) {
        result += command[i];
    }

    return result;
}

static void ldtoypad_scene_emulate_draw_render_callback(Canvas* canvas, void* context) {
    // UNUSED(context);
    LDToyPadSceneEmulateModel* model = context;

    // when the usb device is not set in modek, set it
    if(model->usbDevice == NULL) {
        model->usbDevice = get_usb_device();
        model->connection_status = "USB device setting...";
    }
    if(model->connected) {
        model->connection_status = "Connected to game";

        // send 56 0b 01 00 00 00 04 9a 74 6a 0b 40 80 a9 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00

        // char buffer[32];

        // memset(buffer, 0, sizeof(buffer));

        // // set the data to the buffer
        // buffer[0] = 0x56;
        // buffer[1] = 0x0b;
        // buffer[2] = 0x01;
        // buffer[3] = 0x00;
        // buffer[4] = 0x00;
        // buffer[5] = 0x00;
        // buffer[6] = 0x04;
        // buffer[7] = 0x9a;
        // buffer[8] = 0x74;
        // buffer[9] = 0x6a;
        // buffer[10] = 0x0b;
        // buffer[11] = 0x40;
        // buffer[12] = 0x80;
        // buffer[13] = 0xa9;

        // usbd_ep_write(model->usbDevice, 0x81, buffer, sizeof(buffer));

    } else if(get_connected_status()) {
        model->connected = true;
        model->connection_status = "USB Awoken";
    } else if(model->usbDevice == NULL) {
        model->connection_status = "USB not yet connected";
    } else if(!model->connected) {
        model->connection_status = "Trying to connect USB";
    }

    // when there are characters in emulator->tokens for debugging show them
    if(emulator->token_count > 0) {
        char string_debug[128];
        memset(string_debug, 0, sizeof(string_debug));
        for(int i = 0; i < emulator->token_count; i++) {
            Token token = emulator->tokens[i];
            // print the index and id of the token
            snprintf(
                string_debug + strlen(string_debug),
                sizeof(string_debug),
                "index: %d, id: %d\n",
                token.index,
                token.id);
        }
        snprintf(
            string_debug + strlen(string_debug),
            sizeof(string_debug),
            "tc: %d\n",
            emulator->token_count);
        set_debug_text_ep_in(string_debug);
    }

    if(model->selected_minifigure_index > 0) {
        model->selected_minifigure_index = 0;

        unsigned char buffer[32];

        memset(buffer, 0, sizeof(buffer));

        Token character1 = createCharacter(1);
        character1.pad = selectedBox;
        // ToyPadEmu_place(character1);

        character1.index = emulator->token_count;
        emulator->tokens[character1.index] = character1;
        emulator->token_count++;

        // set the data to the buffer
        buffer[0] = 0x56; // magic number always 0x56
        buffer[1] = 0x0b; // size always 0x0b (11)
        // buffer[2] = 0x01; // pad number?
        buffer[2] = character1.pad;
        buffer[3] = 0x00; // always 0
        // buffer[4] = 0x00; //
        buffer[4] = character1.index;
        buffer[5] = 0x00; // tag placed / removed
        buffer[6] = character1.uid[0]; // first uid always 0x04
        buffer[7] = character1.uid[1];
        buffer[8] = character1.uid[2];
        buffer[9] = character1.uid[3];
        buffer[10] = character1.uid[4];
        buffer[11] = character1.uid[5];
        buffer[12] = character1.uid[6]; // last uid byte 0x80
        // buffer[13] = 0xa9; // checksum
        // generate the checksum
        buffer[13] = generate_checksum_for_command(buffer, 13);

        usbd_ep_write(model->usbDevice, 0x81, buffer, sizeof(buffer));

        // convert the buffer to a string
        // char string_debug[128];
        // memset(string_debug, 0, sizeof(string_debug));
        // hexArrayToString(buffer, HID_EP_SZ, string_debug, sizeof(string_debug));
        // // set the debug_text_ep_in to the string
        // set_debug_text_ep_in("nothing");
        // set_debug_text_ep_in(string_debug);

        // free(uid);
    }
    // poll the USB status here
    // usbd_poll(model->usbDevice);

    canvas_clear(canvas);
    canvas_set_font(canvas, FontSecondary);

    // canvas_draw_str_aligned(canvas, (128 - 40), 5, AlignCenter, AlignTop, "Select here");
    // canvas_draw_str(canvas, 2, 7, "Emulate ToyPad");

    canvas_draw_icon(canvas, 10, 13, &I_toypad);

    // Get position for the selected box
    uint8_t x = boxInfo[selectedBox][0];
    uint8_t y = boxInfo[selectedBox][1];
    // Check if the selectedBox is 1 (circle) and draw the circle, This is hardcoded for now.
    if(selectedBox == 1) {
        canvas_draw_xbm(canvas, x, y, 22, 17, I_selectionCircle); // Draw highlighted circle
    } else {
        canvas_draw_xbm(canvas, x, y, 18, 18, I_selectionBox); // Draw highlighted box
    }

    canvas_set_font(canvas, FontPrimary);
    // elements_button_left(canvas, "Prev");
    // elements_button_center(canvas, "OK");
    // elements_button_right(canvas, "Next");

    elements_multiline_text_aligned(canvas, 1, 1, AlignLeft, AlignTop, model->connection_status);

    // Testing pressing buttons
    // if(model->ok_pressed) {
    //     canvas_set_color(canvas, ColorWhite);
    //     canvas_draw_box(canvas, 43, 28, 64, 16);
    //     canvas_set_color(canvas, ColorBlack);
    //     elements_multiline_text_aligned(canvas, 45, 30, AlignLeft, AlignTop, "OK pressed");
    // }

    // canvas_set_color(canvas, ColorWhite);
    // canvas_draw_box(canvas, 0, 16, 120, 16);
    // canvas_set_color(canvas, ColorBlack);

    // elements_multiline_text_aligned(canvas, 1, 17, AlignLeft, AlignTop, "ep_in: ");
    // elements_multiline_text_aligned(canvas, 40, 17, AlignLeft, AlignTop, get_debug_text_ep_in());

    if(get_debug_text_ep_in() != NULL && strcmp(get_debug_text_ep_in(), "nothing") != 0) {
        canvas_set_color(canvas, ColorWhite);
        canvas_clear(canvas);
        canvas_set_color(canvas, ColorBlack);

        elements_multiline_text_aligned(canvas, 1, 1, AlignLeft, AlignTop, get_debug_text_ep_in());
    }

    canvas_set_color(canvas, ColorWhite);
    canvas_draw_box(canvas, 0, 16, 120, 16);
    canvas_set_color(canvas, ColorBlack);

    elements_multiline_text_aligned(canvas, 1, 17, AlignLeft, AlignTop, "Debug: ");
    elements_multiline_text_aligned(canvas, 40, 17, AlignLeft, AlignTop, get_debug_text());
}

static uint32_t ldtoypad_scene_emulate_navigation_submenu_callback(void* context) {
    UNUSED(context);

    // if(usb_mode_prev != NULL) {
    //     furi_hal_usb_set_config(usb_mode_prev, NULL);
    //     free(usb_mode_prev);
    // }

    return ViewSubmenu;
}

void ldtoypad_scene_emulate_view_game_timer_callback(void* context) {
    UNUSED(context);
    // LDToyPadSceneEmulate* app = (LDToyPadSceneEmulate*)context;
    view_dispatcher_send_custom_event(get_view_dispatcher(), 0);
}

void ldtoypad_scene_emulate_enter_callback(void* context) {
    uint32_t period = furi_ms_to_ticks(150);
    LDToyPadSceneEmulate* app = (LDToyPadSceneEmulate*)context;
    furi_assert(app->timer == NULL);
    app->timer = furi_timer_alloc(
        ldtoypad_scene_emulate_view_game_timer_callback, FuriTimerTypePeriodic, app);
    furi_timer_start(app->timer, period);
}

void ldtoypad_scene_emulate_exit_callback(void* context) {
    LDToyPadSceneEmulate* app = (LDToyPadSceneEmulate*)context;
    furi_timer_stop(app->timer);
    furi_timer_free(app->timer);
    app->timer = NULL;
}

static bool ldtoypad_scene_emulate_custom_event_callback(uint32_t event, void* context) {
    LDToyPadSceneEmulate* scene = (LDToyPadSceneEmulate*)context;
    switch(event) {
    case 0:
        // Redraw screen by passing true to last parameter of with_view_model.
        {
            bool redraw = true;
            with_view_model(
                ldtoypad_scene_emulate_get_view(scene),
                LDToyPadSceneEmulateModel * _model,
                { UNUSED(_model); },
                redraw);
            return true;
        }
    default:
        return false;
    }
}

LDToyPadSceneEmulate* ldtoypad_scene_emulate_alloc(LDToyPadApp* new_app) {
    furi_assert(new_app);
    app = new_app;

    if(emulator == NULL) emulator = malloc(sizeof(ToyPadEmu));

    LDToyPadSceneEmulate* instance = malloc(sizeof(LDToyPadSceneEmulate));
    instance->view = view_alloc();

    // ldtoypad_view_dispatcher = view_dispatcher;

    usb_mode_prev = furi_hal_usb_get_config();

    furi_hal_usb_unlock();
    furi_check(furi_hal_usb_set_config(&usb_hid_ldtoypad, NULL) == true);

    view_set_context(instance->view, instance);
    view_allocate_model(instance->view, ViewModelTypeLockFree, sizeof(LDToyPadSceneEmulateModel));
    // view_set_draw_callback(instance->view, ldtoypad_scene_emulate_draw_callback);
    view_set_draw_callback(instance->view, ldtoypad_scene_emulate_draw_render_callback);
    view_set_input_callback(instance->view, ldtoypad_scene_emulate_input_callback);
    // view_set_enter_callback(instance->view, ldtoypad_scene_emulate_enter_callback);
    // view_set_exit_callback(instance->view, ldtoypad_scene_emulate_exit_callback);
    view_set_previous_callback(instance->view, ldtoypad_scene_emulate_navigation_submenu_callback);

    view_set_enter_callback(instance->view, ldtoypad_scene_emulate_enter_callback);

    view_set_exit_callback(instance->view, ldtoypad_scene_emulate_exit_callback);

    view_set_custom_callback(instance->view, ldtoypad_scene_emulate_custom_event_callback);

    // Allocate the submenu
    // selectionMenu = submenu_alloc();
    // view_set_previous_callback(submenu_get_view(selectionMenu), selectionMenu_prev_callback);
    // view_dispatcher_add_view(
    //     ldtoypad_view_dispatcher, LDToyPadView_SelectionMenu, submenu_get_view(selectionMenu));

    // Items for the submenu as characters and vehicles

    return instance;
}

void ldtoypad_scene_emulate_free(LDToyPadSceneEmulate* ldtoypad_emulate_view) {
    furi_assert(ldtoypad_emulate_view);
    view_free(ldtoypad_emulate_view->view);
    // view_free(submenu_get_view(selectionMenu));

    // // Change back profile
    if(usb_mode_prev != NULL) {
        furi_hal_usb_set_config(usb_mode_prev, NULL);
    }
    free(usb_mode_prev);

    free(ldtoypad_emulate_view);

    free(emulator);
}

View* ldtoypad_scene_emulate_get_view(LDToyPadSceneEmulate* instance) {
    furi_assert(instance);
    return instance->view;
}

void minifigures_submenu_callback(void* context, uint32_t index) {
    LDToyPadApp* app = (LDToyPadApp*)context;

    // print index of selected minifigure as debug text
    // char debug_text[10];
    // // convert the long unsigned int to a string
    // snprintf(debug_text, 10, "%ld", index);
    // // set the debug text
    // set_debug_text(debug_text);

    // set current view to minifigure number to the selected index
    with_view_model(
        ldtoypad_scene_emulate_get_view(app->view_scene_emulate),
        LDToyPadSceneEmulateModel * model,
        {
            model->selected_minifigure_index = index;
            // send_minifigure(model->selected_minifigure_index);
            // ToyPadEmu_place(
            //     get_emulator(), selectedBox + 1, model->selected_minifigure_index, NULL);
        },
        true);

    view_dispatcher_switch_to_view(app->view_dispatcher, ViewEmulate);
}
