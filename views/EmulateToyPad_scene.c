#include "EmulateToyPad_scene.h"

#include "../ldtoypad.h"

#include <furi.h>
#include <furi_hal.h>

/* generated by fbt from .png files in images folder */
#include <ldtoypad_icons.h>

#include <gui/elements.h>
// #include <gui/icon_i.h> // Not yet needed apparently

#include "dolphin/dolphin.h"

#define numBoxes 7 // the number of boxes (7 boxes always)

LDToyPadApp* app;

FuriHalUsbInterface* usb_mode_prev = NULL;

// Selection box icon
uint8_t I_selectionBox[] = {0xf8, 0xff, 0x00, 0x06, 0x00, 0x01, 0x03, 0x00, 0x02, 0x03, 0x00,
                            0x02, 0x03, 0x00, 0x02, 0x03, 0x00, 0x02, 0x03, 0x00, 0x02, 0x03,
                            0x00, 0x02, 0x03, 0x00, 0x02, 0x03, 0x00, 0x02, 0x03, 0x00, 0x02,
                            0x03, 0x00, 0x02, 0x03, 0x00, 0x02, 0x03, 0x00, 0x02, 0x03, 0x00,
                            0x02, 0x07, 0x00, 0x03, 0xfe, 0xff, 0x01, 0xfc, 0xff, 0x00};

//  Selection circle icon
uint8_t I_selectionCircle[] = {0x80, 0x7f, 0x00, 0xf0, 0xff, 0x03, 0xf8, 0xc0, 0x07, 0x3c, 0x00,
                               0x0f, 0x0c, 0x00, 0x0c, 0x06, 0x00, 0x18, 0x07, 0x00, 0x38, 0x07,
                               0x00, 0x38, 0x03, 0x00, 0x30, 0x03, 0x00, 0x30, 0x07, 0x00, 0x38,
                               0x06, 0x00, 0x18, 0x06, 0x00, 0x18, 0x3e, 0x00, 0x1f, 0xf8, 0xc0,
                               0x07, 0xf0, 0xff, 0x03, 0x80, 0x7f, 0x00};

// Define box information (coordinates and dimensions) for each box (7 boxes total)

struct BoxInfo {
    int x; // X-coordinate
    int y; // Y-coordinate
    bool isFilled; // Indicates if the box is filled with a Token (minifig / vehicle)
    int index; // The index of the token in the box
};

struct BoxInfo boxInfo[] = {
    {18, 26, false, -1}, // Selection 0 (box)
    {50, 20, false, -1}, // Selection 1 (circle, assumed not filled)
    {85, 27, false, -1}, // Selection 2 (box)
    {16, 40, false, -1}, // Selection 3 (box)
    {35, 41, false, -1}, // Selection 4 (box)
    {70, 41, false, -1}, // Selection 5 (box)
    {86, 40, false, -1} // Selection 6 (box)
};

struct LDToyPadSceneEmulate {
    View* view;
    // LDToyPadSceneEmulateCallback callback;
    // void* context;

    // timer
    FuriTimer* timer; // Timer for redrawing the screen
};

// The selected pad on the toypad
uint8_t selectedBox = 0; // Variable to keep track of which toypad box is selected

bool ldtoypad_scene_emulate_input_callback(InputEvent* event, void* context) {
    LDToyPadSceneEmulate* instance = context;
    furi_assert(instance);

    bool consumed = false;

    with_view_model(
        instance->view,
        LDToyPadSceneEmulateModel * model,
        {
            // when the OK button is pressed, we want to switch to the minifigure selection screen for the selected box
            if(event->key == InputKeyOk) {
                if(event->type == InputTypePress && model->connected) {
                    model->ok_pressed = true;

                    // if the current selected box is not filled, we want to switch to the minifigure selection screen
                    if(!boxInfo[selectedBox].isFilled) {
                        // set current view to minifigure selection screen
                        view_dispatcher_switch_to_view(
                            app->view_dispatcher, ViewMinifigureSelection);
                    } else if(boxInfo[selectedBox].isFilled) {
                        // if the box is filled, we want to remove the minifigure from the selected box

                        // get the index of the minifigure in the selected box
                        int i = -1;

                        // check if the selected box in boxInfo get the token index
                        if(boxInfo[selectedBox].index >= 0) {
                            i = boxInfo[selectedBox].index;

                            if(ToyPadEmu_remove(i, selectedBox)) {
                                // set the box to not filled
                                boxInfo[selectedBox].isFilled = false;

                                // set debug text
                                set_debug_text("Removed minifigure from toypad");
                            }
                        }
                    }

                    consumed = true;
                    return consumed;

                } else if(event->type == InputTypeRelease) {
                    model->ok_pressed = false;
                }
            }
            // make user loop through boxes with InputKeyLeft, InputKeyRight, InputKeyUp, InputKeyDown
            if(event->key == InputKeyLeft) {
                if(event->type == InputTypePress) {
                    model->left_pressed = true;
                    if(selectedBox == 0) {
                        selectedBox = numBoxes;
                    }
                    selectedBox--;
                } else if(event->type == InputTypeRelease) {
                    model->left_pressed = false;
                }
            }
            if(event->key == InputKeyRight) {
                if(event->type == InputTypePress) {
                    model->right_pressed = true;
                    selectedBox++;
                    if(selectedBox >= numBoxes) {
                        selectedBox = 0;
                    }
                } else if(event->type == InputTypeRelease) {
                    model->right_pressed = false;
                }
            }
            if(event->key == InputKeyUp) {
                if(event->type == InputTypePress) {
                    model->up_pressed = true;
                    if(selectedBox == 0) {
                        selectedBox = 3;
                    } else if(selectedBox >= 4) {
                        selectedBox -= 4;
                    } else {
                        selectedBox = (numBoxes - 3) + selectedBox;
                    }
                    if(selectedBox >= numBoxes) {
                        selectedBox = 0;
                    }
                } else if(event->type == InputTypeRelease) {
                    model->up_pressed = false;
                }
            }

            if(event->key == InputKeyDown) {
                if(event->type == InputTypePress) {
                    model->down_pressed = true;
                    if(selectedBox == 2) {
                        selectedBox = 6;
                    } else if(selectedBox == 3) {
                        selectedBox = 0;
                    } else if(selectedBox == 5) {
                        selectedBox = 2;
                    } else if(selectedBox < (numBoxes - 3)) {
                        selectedBox += 3;
                    } else {
                        selectedBox = selectedBox - (numBoxes - 3);
                    }
                } else if(event->type == InputTypeRelease) {
                    model->down_pressed = false;
                }
            }
        },
        true);

    return consumed;
}

unsigned char generate_checksum_for_command(const unsigned char* command, size_t len) {
    // Assert that the length of the command is less than or equal to 31
    // assert(len <= 31);

    unsigned char result = 0;

    // Add bytes, wrapping naturally with unsigned char overflow
    for(size_t i = 0; i < len; ++i) {
        result += command[i];
    }

    return result;
}

void selectedBox_to_pad(Token* new_character, int selectedBox) {
    // Convert / map the boxes to pads there are 3 pads and 7 boxes
    // TODO: This needs to be looked at, as I don't know the correct order yet
    switch(selectedBox) {
    case 0:
        new_character->pad = 3;
        break;
    case 1:
        new_character->pad = 1;
        break;
    case 2:
        new_character->pad = 2;
        break;
    case 3:
        new_character->pad = 3;
        break;
    case 4:
        new_character->pad = 3;
        break;
    case 5:
        new_character->pad = 2;
        break;
    case 6:
        new_character->pad = 2;
        break;
    default:
        furi_crash("Selected pad is invalid"); // It should never reach this.
        break;
    }
}

static void ldtoypad_scene_emulate_draw_render_callback(Canvas* canvas, void* context) {
    // UNUSED(context);
    LDToyPadSceneEmulateModel* model = context;

    // when the usb device is not set in modek, set it
    if(model->usbDevice == NULL) {
        model->usbDevice = get_usb_device();
        model->connection_status = "USB device setting...";
    }

    if(get_connected_status() == 2) {
        model->connected = true;
        set_connected_status(
            1); // Set the connected status to 1 (connected) and not 2 (re-connecting)
        model->connection_status = "USB Awoken";

        // reset the filled boxes
        for(int i = 0; i < numBoxes; i++) {
            boxInfo[i].isFilled = false;
        }

        // Give dolphin some xp for connecting the toypad
        dolphin_deed(DolphinDeedPluginStart);
    } else if(model->connected) {
        model->connection_status = "Connected";
    } else if(model->usbDevice == NULL) {
        model->connection_status = "USB not yet connected";
    } else if(!model->connected) {
        model->connection_status = "Trying to connect USB";
    }

    if(model->selected_minifigure_index > 0 && model->connected) {
        int id = (int)model->selected_minifigure_index;
        model->selected_minifigure_index = 0;

        unsigned char buffer[32];

        memset(buffer, 0, sizeof(buffer));

        if(id < 1) {
            id = 1;
        }

        Token* character = createCharacter(id);

        boxInfo[selectedBox].isFilled = true;

        selectedBox_to_pad(character, selectedBox);

        character->index = emulator->token_count;
        emulator->tokens[character->index] = character;
        emulator->token_count++; // Set the token count for a new character

        boxInfo[selectedBox].index = character->index;

        // set the data to the buffer
        buffer[0] = 0x56; // magic number always 0x56
        buffer[1] = 0x0b; // size always 0x0b (11)
        buffer[2] = character->pad;
        buffer[3] = 0x00; // always 0
        buffer[4] = character->index;
        buffer[5] = 0x00; // tag placed / removed
        buffer[6] = character->uid[0]; // first uid always 0x04
        buffer[7] = character->uid[1];
        buffer[8] = character->uid[2];
        buffer[9] = character->uid[3];
        buffer[10] = character->uid[4];
        buffer[11] = character->uid[5];
        buffer[12] = character->uid[6]; // last uid byte always 0x80
        // generate the checksum
        buffer[13] = generate_checksum_for_command(buffer, 13);

        usbd_ep_write(model->usbDevice, 0x81, buffer, sizeof(buffer));

        // Give dolphin some xp for placing a minifigure
        dolphin_deed(DolphinDeedNfcReadSuccess);
    }

    canvas_clear(canvas);
    canvas_set_font(canvas, FontPrimary);

    // Draw the big toypad image as decoration for the background of the screen
    canvas_draw_icon(canvas, 10, 13, &I_toypad);

    // Get position for the selected box
    uint8_t x = boxInfo[selectedBox].x;
    uint8_t y = boxInfo[selectedBox].y;
    // Check if the selectedBox is 1 (circle) and draw the circle, This is hardcoded for now.
    if(selectedBox == 1) {
        canvas_draw_xbm(canvas, x, y, 22, 17, I_selectionCircle); // Draw highlighted circle
    } else {
        canvas_draw_xbm(canvas, x, y, 18, 18, I_selectionBox); // Draw highlighted box
    }

    // when the box is filled, draw the minifigure icon
    for(int i = 0; i < numBoxes; i++) {
        if(boxInfo[i].isFilled) {
            // Draw the minifigure icon
            canvas_draw_icon(canvas, boxInfo[i].x + 3, boxInfo[i].y + 3, &I_head);
        }
    }

    elements_multiline_text_aligned(canvas, 1, 1, AlignLeft, AlignTop, model->connection_status);

    if(model->show_debug_text_index) {
        // elements_button_left(canvas, "Prev");
        // elements_button_center(canvas, "OK");
        // elements_button_right(canvas, "Next");

        if(get_debug_text_ep_in() != NULL && strcmp(get_debug_text_ep_in(), "nothing") != 0) {
            canvas_set_color(canvas, ColorWhite);
            canvas_clear(canvas);
            canvas_set_color(canvas, ColorBlack);

            elements_multiline_text_aligned(
                canvas, 1, 1, AlignLeft, AlignTop, get_debug_text_ep_in());
        }

        canvas_set_color(canvas, ColorWhite);
        canvas_draw_box(canvas, 0, 16, 120, 16);
        canvas_set_color(canvas, ColorBlack);

        elements_multiline_text_aligned(canvas, 1, 17, AlignLeft, AlignTop, "Debug: ");
        elements_multiline_text_aligned(canvas, 40, 17, AlignLeft, AlignTop, get_debug_text());
    }
}

static uint32_t ldtoypad_scene_emulate_navigation_submenu_callback(void* context) {
    UNUSED(context);

    // if(usb_mode_prev != NULL) {
    //     furi_hal_usb_set_config(usb_mode_prev, NULL);
    //     free(usb_mode_prev);
    // }

    return ViewSubmenu;
}

void ldtoypad_scene_emulate_view_game_timer_callback(void* context) {
    UNUSED(context);
    // LDToyPadSceneEmulate* app = (LDToyPadSceneEmulate*)context;
    view_dispatcher_send_custom_event(get_view_dispatcher(), 0);
}

void ldtoypad_scene_emulate_enter_callback(void* context) {
    uint32_t period = furi_ms_to_ticks(150);
    LDToyPadSceneEmulate* app = (LDToyPadSceneEmulate*)context;
    furi_assert(app->timer == NULL);
    app->timer = furi_timer_alloc(
        ldtoypad_scene_emulate_view_game_timer_callback, FuriTimerTypePeriodic, app);
    furi_timer_start(app->timer, period);
}

void ldtoypad_scene_emulate_exit_callback(void* context) {
    LDToyPadSceneEmulate* app = (LDToyPadSceneEmulate*)context;
    furi_timer_stop(app->timer);
    furi_timer_free(app->timer);
    app->timer = NULL;
}

static bool ldtoypad_scene_emulate_custom_event_callback(uint32_t event, void* context) {
    LDToyPadSceneEmulate* scene = (LDToyPadSceneEmulate*)context;
    switch(event) {
    case 0:
        // Redraw screen by passing true to last parameter of with_view_model.
        {
            bool redraw = true;
            with_view_model(
                ldtoypad_scene_emulate_get_view(scene),
                LDToyPadSceneEmulateModel * _model,
                { UNUSED(_model); },
                redraw);
            return true;
        }
    default:
        return false;
    }
}

LDToyPadSceneEmulate* ldtoypad_scene_emulate_alloc(LDToyPadApp* new_app) {
    furi_assert(new_app);
    app = new_app;

    if(emulator == NULL) emulator = malloc(sizeof(ToyPadEmu));
    emulator->token_count = 0;
    memset(emulator->tokens, 0, sizeof(emulator->tokens));

    LDToyPadSceneEmulate* instance = malloc(sizeof(LDToyPadSceneEmulate));
    instance->view = view_alloc();

    // ldtoypad_view_dispatcher = view_dispatcher;

    usb_mode_prev = furi_hal_usb_get_config();

    furi_hal_usb_unlock();
    furi_check(furi_hal_usb_set_config(&usb_hid_ldtoypad, NULL) == true);

    view_set_context(instance->view, instance);
    view_allocate_model(instance->view, ViewModelTypeLockFree, sizeof(LDToyPadSceneEmulateModel));
    // view_set_draw_callback(instance->view, ldtoypad_scene_emulate_draw_callback);
    view_set_draw_callback(instance->view, ldtoypad_scene_emulate_draw_render_callback);
    view_set_input_callback(instance->view, ldtoypad_scene_emulate_input_callback);
    // view_set_enter_callback(instance->view, ldtoypad_scene_emulate_enter_callback);
    // view_set_exit_callback(instance->view, ldtoypad_scene_emulate_exit_callback);
    view_set_previous_callback(instance->view, ldtoypad_scene_emulate_navigation_submenu_callback);

    view_set_enter_callback(instance->view, ldtoypad_scene_emulate_enter_callback);

    view_set_exit_callback(instance->view, ldtoypad_scene_emulate_exit_callback);

    view_set_custom_callback(instance->view, ldtoypad_scene_emulate_custom_event_callback);

    // Allocate the submenu
    // selectionMenu = submenu_alloc();
    // view_set_previous_callback(submenu_get_view(selectionMenu), selectionMenu_prev_callback);
    // view_dispatcher_add_view(
    //     ldtoypad_view_dispatcher, LDToyPadView_SelectionMenu, submenu_get_view(selectionMenu));

    // Items for the submenu as characters and vehicles

    return instance;
}

void ldtoypad_scene_emulate_free(LDToyPadSceneEmulate* ldtoypad_emulate_view) {
    furi_assert(ldtoypad_emulate_view);
    view_free(ldtoypad_emulate_view->view);
    // view_free(submenu_get_view(selectionMenu));

    // // Change back profile
    if(usb_mode_prev != NULL) {
        furi_hal_usb_set_config(usb_mode_prev, NULL);
    }
    free(usb_mode_prev);

    free(ldtoypad_emulate_view);

    // free all the tokens ( needs a better solution later )
    for(int i = 0; i < 128; i++) {
        if(emulator->tokens[i] != NULL) {
            free(emulator->tokens[i]);
        }
    }
    free(emulator);
}

View* ldtoypad_scene_emulate_get_view(LDToyPadSceneEmulate* instance) {
    furi_assert(instance);
    return instance->view;
}

void minifigures_submenu_callback(void* context, uint32_t index) {
    LDToyPadApp* app = (LDToyPadApp*)context;

    // print index of selected minifigure as debug text
    // char debug_text[10];
    // // convert the long unsigned int to a string
    // snprintf(debug_text, 10, "%ld", index);
    // // set the debug text
    // set_debug_text(debug_text);

    // set current view to minifigure number to the selected index
    with_view_model(
        ldtoypad_scene_emulate_get_view(app->view_scene_emulate),
        LDToyPadSceneEmulateModel * model,
        {
            if(model->connected) {
                model->selected_minifigure_index = index;
            }
        },
        true);

    view_dispatcher_switch_to_view(app->view_dispatcher, ViewEmulate);
}
